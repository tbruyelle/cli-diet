package network

import (
	"context"
	"fmt"
	"path/filepath"
	"strings"
	"time"

	"github.com/cosmos/cosmos-sdk/client"
	"github.com/cosmos/cosmos-sdk/server"
	"github.com/pkg/errors"
	launchtypes "github.com/tendermint/spn/x/launch/types"

	"github.com/ignite/cli/ignite/pkg/cosmosutil"
	"github.com/ignite/cli/ignite/pkg/ctxticker"
	"github.com/ignite/cli/ignite/pkg/gitpod"
	"github.com/ignite/cli/ignite/pkg/xchisel"
	"github.com/ignite/cli/ignite/services/network/networkchain"
)

func PeerAddress(peer launchtypes.Peer) (string, error) {
	var peerAddr string
	switch conn := peer.Connection.(type) {
	case *launchtypes.Peer_TcpAddress:
		peerAddr = fmt.Sprintf("%s@%s", peer.Id, conn.TcpAddress)
	case *launchtypes.Peer_HttpTunnel:
		peerAddr = fmt.Sprintf("%s@%s", peer.Id, conn.HttpTunnel.Address)
	default:
		return peerAddr, fmt.Errorf("invalid peer connection type: %T", peer.Connection)
	}
	return peerAddr, nil
}

func ParsePeerAddress(addr string) (launchtypes.Peer, error) {
	sp := strings.Split(addr, "@")
	if len(sp) != 2 {
		return launchtypes.Peer{}, errors.New("invalid peer address format")
	}
	return launchtypes.NewPeerConn(sp[0], sp[1]), nil
}

const TunnelRerunDelay = 5 * time.Second

// StartProxyForTunneledPeers starts an HTTP proxy server and HTTP proxy clients
// for each node that needs HTTP tunneling.
// HTTP tunneling is activated **ONLY** if your app's `$APP_HOME/config` dir has an `spn.yml` file
// and only if this file has `tunneled_peers` field inside with a list of tunneled peers/nodes.
//
// If you're using SPN as coordinator and do not want to allow HTTP tunneling feature at all,
// you can prevent `spn.yml` file to being generated by not approving validator requests
// that has HTTP tunneling enabled instead of plain TCP connections.
func StartProxyForTunneledPeers(ctx context.Context, clientCtx client.Context, serverCtx *server.Context) {
	spnConfigPath := filepath.Join(clientCtx.HomeDir, cosmosutil.ChainConfigDir, networkchain.SPNConfigFile)
	spnConfig, err := networkchain.GetSPNConfig(spnConfigPath)
	if err != nil {
		serverCtx.Logger.Error("Failed to open spn config file", "reason", err.Error())
		return
	}
	// exit if there aren't tunneled validators in the network
	if len(spnConfig.TunneledPeers) == 0 {
		return
	}

	for _, peer := range spnConfig.TunneledPeers {
		if peer.Name == networkchain.HTTPTunnelChisel {
			peer := peer
			go func() {
				ctxticker.DoNow(ctx, TunnelRerunDelay, func() error {
					serverCtx.Logger.Info("Starting chisel client", "tunnelAddress", peer.Address, "localPort", peer.LocalPort)
					err := xchisel.StartClient(ctx, peer.Address, peer.LocalPort, "26656")
					if err != nil {
						serverCtx.Logger.Error("Failed to start chisel client",
							"tunnelAddress", peer.Address,
							"localPort", peer.LocalPort,
							"reason", err.Error(),
						)
					}
					return nil
				})
			}()
		}
	}

	if gitpod.IsOnGitpod() {
		go func() {
			ctxticker.DoNow(ctx, TunnelRerunDelay, func() error {
				serverCtx.Logger.Info("Starting chisel server", "port", xchisel.DefaultServerPort)
				err := xchisel.StartServer(ctx, xchisel.DefaultServerPort)
				if err != nil {
					serverCtx.Logger.Error(
						"Failed to start chisel server",
						"port", xchisel.DefaultServerPort,
						"reason", err.Error(),
					)
				}
				return nil
			})
		}()
	}
}
